# 2021/2/26-

1. CSS
2. Vue
3. 小程序

# 2021

年度任务

1. 重新过一遍Vue（4）
1. 基于TS重写md，同时把js datatool剩下部分完成（5）
1. 自动处理word笔记到个人网站（6）
1. 将md功能做成APP（7）
1. 长期：leetcode代码提交，保持python手感和C++语感；个人网站后端全部采用python，放弃node;源码阅读；英语能力提升

## 三月

1. python设计模式视频剩余部分，完成
2. 重新过一遍JS设计模式，完成，发现以前整理过观察者模式和发布订阅者的区别，整理了这么多页居然没另外花时间消化背诵下，有毒
3. AST，感谢指点，我果然是野生的，因为不喜欢github markdown，macos word体验没有windows好，自己写了个markdown，功能都实现了，不想用：①代码太丑②难以维护，然后跑去重新补基础，撇开这些不谈，单就逻辑实现而言，虽然尝试看了编译原理，最后还是最简单的两步：①将文本解析成token tree②将token tree渲染回想要的内容（渲染成html或txt）。比之前看的一些源码的优化在于：使用stack做解析和渲染，而不是递归，也没有用正则这种拖后腿的，文本解析时间复杂度基本O(n)，只有一次循环，剩下只是用于构建tree过程，渲染也只过了一次深度优先遍历。然后剩下的关注点一直在怎么写一个万能解析器，这个又回到了编译原理，这两天看AST发现自己之前的方向还是偏了，格局不够，之前知识面不够。
4. 重新过了一遍JS，不过应用、操作、原理深入等是长期的。

## 二月

整理笔记与沟通：

1. 错误评估Vue的价值，一直以为Vue只是一个工具，没有特别重要，发现大多数公司都不是这样的，需要重新学习Vue
2. 错误评估全栈开发，以为node后端已经非常流行，实际不是，node基本只是作为前端开发工具，很少有公司使用后端技术，哪怕用也只是不重要的部分，node注定退出历史舞台，期待deno
3. 错误定位原理的价值，原理需要根据情况分类①使用涉及原理②配置原理。比如vue的相关原理是使用原理，需要着重掌握，再比如cors属于配置原理，对前端的配置只是一个是否携带cookies，后端基本都有第三方库，只需照着教程安装配置，诚然了解cors http header怎么交互，浏览器怎么处理，确实有助于理解cors配置，但这种有助于是一次性的，在时间精力有限的情况下，应该减少这种一次性输出的投入。
4. 错误评估面向对象、设计模式、数据结构与算法在前端的重要性，一直以为这些很重要，但其实如果工作大多涉及应用，第三方库的使用，这些不涉及很正常；只有自己写第三方库，经常处理后端数据，前端工作涉及底层，这些的重要性才会被凸显出来，没有面向对象就无法开发大型工程，工程代码将难以维护。

调整：

1. 重新学习vue
2. 放弃node后端开发：除非工作有需要，或者需要ssr，或者静态资源服务器的修改（集成md等）
3. 原理学习注意分清主次，以应用or配置为标准，而不是喜好为标准，将精力花在刀刃上
4. 面向对象、设计模式、数据结构与算法等，不论工作是否需要，都不能放弃，数据结构与算法之前在其他网站上提交的代码，后续跑大家都用的网站，用三种语言刷题（JS、python、C++）


## 一月
Vue源码，只到diff，后续继续

# 需求与方案
<!--之前面试有意无意隐藏了项目需求分析部分，主要是后端、需求、前端，感觉前端最薄弱，想找薄弱的补补。-->
早期做需求发现不了解技术的需求容易耍流氓：“反正用户需要这个功能，你给我实现。”内心OS，这个看着就很简单的样子；写后端发现需求主要体现在前端，写前端发现前端一天一个样，花样繁多，眼花缭乱。

## 大致过程
1. 收集大致需求：功能、目标、规模（数据规模，用户规模，时间粒度）、使用群体等。这些会影响数据库设计、界面设计、性能要求
2. 罗列所有影响因素及其关系，同时在后续不断头脑风暴补充
3. 明确信息输入、输出，系统在输入输出中间做了什么，在脑中搭建用户使用场景
4. 绘制流程图，业务的、原理的、使用步骤等，并尽可能了解其他解决方案
5. 给功能分类，短期中长期

常用文档：方案、部署指导、进度与责任人跟踪表、接口文档、数据库表结构设计，配置复杂点可能有一个配置说明文档

## 理清相互关系

一对一、一对多、多对多

### 案例
1. JS prototype实际是一对一关系，所以只能单继承
1. 权限5表经典设计，是两个多对多关系
1. 流程审批系统存储数据库存储链表结构，主要是一对一关系（之所以是链表而不是其他顺序存储，取决于审批流程的特性）
1. 配置文件设计
1. json有时候可以直接当tree使用，也就是一对多关系，不过json的一对多是单向的

### 数据结构与算法

1. 1对1关系：顺序存储
1. 1对多关系：树
1. 多对多关系：图

### 数据库

#### 传统关系型数据库表结构设计


1. 1对1关系：一张表，每条数据一个关系
1. 1对多关系：两张表，一张基础表，一张外键关联表
1. 多对多关系：三张表，两张基础表，一张关联表，外键关联表示两者之间的关系


#### 非关系型数据库表结构设计

目前只接触过MongoDB、Redis，一个是最像关系型数据库的非关系型数据库，一个是key value形式的数据库，两者都比较像下面数据类型关系处理。用习惯关系型数据库用这些，最不适应的就是冗余。



### 数据类型

一个没有深层的Object Array，就是一个一对一关系（python中的字典和list，C和C++中没有直接类似字典这样的类型，但是比如结构体、枚举类型，基本都是一对一关系，也有数组）


当进行深层嵌套，树状图展示就是一对多关系


多对多关系可能存在数据的冗余，但也能在数据类型中使用





## XML在线编辑器
因为要工作交接，翻出方案重新过了一遍代码，想偷图和前端代码，可惜公司管的严。


### XML作用
实际业务应用涉及生产测试与自动化测试，比如一只手机，在出厂前要进行组装、测试等环节，确保硬件、软件符合出厂标准。


原本自动化测试脚本是测试包（由自动化测试平台调用，里面包含了xml，平台测试时会自动加载xml，读取测试序列），基本每个产品的每个工序一个独立测试包（很少共用），实际不同工序、不同产品测试存在测试共性，比如IT产品线基本都有硬盘、CPU、内存，存在大量代码复用，开发使用模板外，更多的只是复制黏贴，属于原始粗暴作业。


模块化就是根据共性抽象成模块，所有产品、所有测试工序只有一个测试包，那些不能模块化的主要有两部分：1、产品差异、版本差异（软件版本、OS版本）、交付件类型差异：抽象为配置（db or config）。2、测试工序变成xml，xml描述了测试序列、关键项、调用的模块化函数、以及测试完成是否重启，使用哪种重启等各种与测试工序本身相关的信息。


完全模块化后，测试人员只需要做两件事：
1. 维护公共模块，以前是一个测试人员维护一个工序的测试包，现在变成一个测试人员研究一个小模块（比如以前一个人维护ST工序测试脚本，脚本里有硬盘、内存、CPU、GPU、主板等所有相关硬件测试，模块化后，测试人员只被分配到硬盘，专攻硬盘研究）
2. 配置XML，XML是一个文本，可以在文本编辑器随意修改，但生产测试任意一个细小错误都可能导致生产线停摆（特别是不做库存的产品，停线是重大生产事故），所以需要界面在线编辑，规范操作。


显而易见的，模块化提高代码复用水平，提升人员专业程度，减少生产事故（通常接口人只会对接一部分产品，比如Intel工具有修改软件不兼容，他会把这部分信息传递给自己对接的所有产品，并且传递给其他接口人。实际情况是，要么信息没有传递，要么传递了但其他接口人没有重视，要么有的开发人员很好的实现了修改，有的改错了，总而言之，各种各样的原因都会导致生产事故，而这种生产事故一回溯就要命，明明你们都知道，居然还能犯错，特别是大客户急单，简直要命）


在线编辑的目的：约束开发人员操作，规范XML，防止低级错误导致生产问题，同时规范每个节点及其属性，后续扩展为自动下发测试（仿HW）


### 分析过程
1. 将xml抽象成tree，了解每个节点的需求。理论上来说XML本身就是tree，但由于界面主要目的是约束，这里每个节点要求和规范不同。最终体现在node的属性、是否有子节点、子节点、数据源等。另外实际业务导致这棵树不是纯粹的树，比如第一个子树是其他子树部分数据的数据源（1对多）。
2. 整理node，了解每个node的弹框要求，信息要求，差异与共同点，尝试抽出相同部分。
3. 其他需求，如何确保数据持久化，生成的XML是否要进行版本管理
4. 获得所有相关关系后，罗列一期二期三期开发功能

实现：
1. 一期实现：在线编辑，增删改移动，约束所有节点（基本都是前端内容）
2. 二期规划：持久化、版本管理、自动下发测试（前后端一半一半）
3. 其他规划：测试脚本自动化测试（测试脚本在下发生产测试使用前，会进行一系列测试，可以模拟硬件自动化测试）

一期效果：
1. 几乎所有内容包括几十个弹框（每个节点需求不一样，弹框内容不一样），全部抽象为json，通过配置实现界面显示控制。
2. 只要总体方案不改，xml框架不改，后续只需维护配置文件
3. 同时预留后续开发，假如想要做PS history的功能，轻松自如地切换历史操作。那会儿有毒，天天加班还给自己加功能，这是我想做的，没机会做二期，想把这个预留交接，结果同事一直质问我为什么不存最终值，而是存操作，不要问我为什么，因为之前看见mongodb用操作同步数据，觉得这个想法好天才。


不足：开发测试上线共5周，需求方案2天（事先梳理过模块化总方案），tree node简单的核心操作一周（tree的深度优先遍历与node节点的增删改移动），界面配置抽象与开发3周，测试修改上线1周。时间过于压缩，tree node的代码不具有通用性，经常用deep copy（节点初始化），直接用了序列化和反序列化，然后为了便于序列化，只做了json（单向，没有双向），所以操作都是通过父节点操作的（虽然为了预留后续扩展，写了单向到双向双向到单向的转换，但其实也只是为了实现而实现，而不是为了通用而实现）。预留history功能一开始只是梳理了增、删、移动、修改，没有把其他因素考虑进来，导致开发到月底差点崩盘，预留扩展比较生硬原始。

## 布局
原因：改动特别大，三天两头改


局限：现有要求布局本质上还是简单的等分布局（虽然有的地方处理后预留空白看上去不像）


方法：
1. 将显示与实际数据分离，显示只配置布局，不关心数据库数据是否正确
2. 将布局抽象（局限意味着目前抽象虽然复杂，但没有那么复杂，最终也只是五维数组，分别表示page row col shell item，每个工位也只有几种状态：正常、删除、占位，其余工位状态与测试状态组合上百种不会再影响这里的布局）
3. 在线操作布局，将布局和样式分开（目前只实现了在线操作布局，没有在线操作样式）


配置抽象关系抽离：理论上来说开发都是抽象业务，但是由于和业务紧密结合，如果不在概念上做一层抽离，容易混乱。刚临时出了个需求，xx市长今天去参观，我请假了一周，临时大改布局，由于之前没有做这一层抽象，通过回忆，只能回忆到业务上屏幕有几种逻辑配置，然后整个思维就被限定在业务里，需要为了整个cm单独走代码分支。幸好维护人员突然想到，其实跳出业务范畴，这就是一个一对多关系（配置本来就用了一对多关系开发，只是因为业务一直一对一，然后就把自己绕进去了）。现有的很多配置，其实都直接做了一对多（多对多比较少），而这些一对多大多数在使用上只上一对一（主要是从一对一改成一对多的情况比较多，也比较好改，所有看到一对一情况，顺手写成一对多）。这些多做的事，可能为后面节省了时间，但也可能导致今天这种情况，实际开发可以支持多种需求，但由于经常不用，导致只关注业务忘记逻辑。


## 配置抽象
之前系统频繁变动，后面开发尽量将变动内容做了配置抽象，交接时是发现很多配置。

### 自省
系统运行时了解自身所处位置


适用：适用于同一系统多地部署，不同部署地需要差异展现，具体表现在如首页不同、导航栏不同（属地有权限）、后端接口不同、单点登录系统不同、部分界面配置设置不同。


特性：这是一个不常变化的配置，可以直接写在静态部署地的静态文件中(部署不替换)

### 导航栏
抽象成一棵多叉树（普通树，树规模不大），对导航栏做一次前序遍历，期间通过配置进行初始化、过滤、权限以及其他是否显示、移除等操作（权限是异步获取多个系统的权限，实际存在时间问题，目前只是1、获取ajax数据2、处理其他逻辑3、最后过滤权限，后续类似功能最好参照下面通用按钮处理）


### 弹框（含表单）
抽象成json，包括：
1. 表单内容：显示那些内容（是否显示），每个内容的数据源
3. 表单初始化：是否进行初始化，比如新增一般只考虑数据源和简单初始化，但修改需要初始化整个表单
4. 表单操作控制：是否可修改，是否需要根据选择修改数据源
5. 校验：表单里的每个值，是否需要校验，校验规则是什么（那些不提交的值也可能需要进行校验）
6. 表单提交：是否提交表单，提交表单时使用什么key

### 通用按钮
抽象成json，按钮通常有：
1. 是否显示：isShow
2. 是否可用（没合在一个因为用户需求不一样，有的想有的按钮不用就不要显示，有的希望不同显示但不可用）:disabled
3. 颜色、样式、动画：class
4. 其他显示差异：文字、大小等:使用props等
5. 逻辑差异，比如提交后端接口不一样：单独封装一个类，做接口处理，json里只指定这个类区分的方式，比如类型
6. 其他映射到上面属性的逻辑差异：每个单独罗列，在过滤时做逻辑（为了可阅读性，如果单独抽离出去，后续这个配置文件不好阅读，不利于维护，并且容易出错）

过程（之所以会有以下两步，因为有的初始化涉及一些异步数据，如果要等异步数据来了才加载出来，有长期空白，所以给了一个最小配置的初始化，当然实际也可以识别哪些字段是异步的，只对异步数据做最小配置，不过当时没后面方式）：
1. 初始化：初始化时给与最小配置（比如都不可用）
2. 加载
3. update

### 前端逻辑配置
包括：
1. 状态，比如工位状态、测试状态，所有状态都需要配置
2. 前端查询（不是后端做查询基本都要抽象，可能因为需求经常改动）
3. 前端筛选控制显示（比如那几个状态需要单独详细显示，其他只要简要显示，相似布局前后顺序等）


# 野路子（2016-2021）
最近面试，和同事聊我的情况，发现自己是非常野的野路子，与正统前端不太一样，以下是过去五年的野路子行径（当然很多学校里都学过，纯粹是回头补复习，排名不分先后），虽然都写了笔记，有的学完就忘，希望未来5年专注学习方向，再想其他～～


编号	名称	状态
1. python基础语法	
1. django框架基础	
1. python面向对象编程	：python居然没有interface
1. python网络编程	：简易ssh，简易ftp，沾包很有趣，后来看见node使用pip管道，流式协议的特性！（http基于tcp）
1. python并发编程	
1. 计算机网络	
1. django restful + vue	
1. django xadmin实战	
1. 操作系统	
1. 计算机组成原理：前面看的很有趣，后面看晕了	
1. 前端基础	
1. 响应式布局：找的一个国外的教程（回头看很简单，当时第一次接触觉得这个思路好厉害）	
1. vue	
1. koa2 restful	
1. ES6	
1. node静态资源服务器	：原来web后端框架是这样开始的
2. less sass
3. typescirpt：怎么这么像C#，回头一看都是微软的
4. engines
5. 小程序：被拒无数次，要求企业资质，简直有毒
6. python数据结构与算法，看的简单版，也研究了好久，有的概念直到找出C++版的才理解，前几天回头整理笔记，发现这里的笔记很简单
7. 机器学习	暂停，其实蛮有趣的，就是数学基础不行
8. 高数，线代	暂停
9. C++基础	
10. C++进阶	
11. C++标准库	放弃，选的视频很好，就是以后不干这个，还是不深入学了
12. C++数据结构与算法	未完成
13. mongodb	
14. redis	
15. linux操作基础	
16. Javascript设计模式	完成，书虽然绝版了比较久远，但写的很好，理解不彻底，需要找python和C++的对照着看
17. python设计模式	未完成，教程很好
18. C++设计模式	未完成，书写的很棒
19. canvas 小球运动与图片处理，发现到后面都是数学问题，永远都能发现数学问题
20. 计算机图形学 暂停，教材是英文版的，很有难度，视频很不错，c++
21. 编译原理 暂停，暂时没找到不错的视频，找到的几个都在照本宣科
22. vue源码 未完成，一开始觉得视频不错，后面发现得自己重新理解、归纳，看到diff算法部分，视频没说明这是diff算法，只用了简单嵌套组件尝试了下，还以为是纯粹的渲染过程


其他（有毒系列）


1. AE（学了几十个课，有毒，不过AE确实很强大）
1. 延时摄影 （不可置信，开的公众号都被锁了～～～）
2. C4D 放弃（真有毒系列，居然还研究过这个，丢出小球穿破布料，掉在地上，要有布料的撕裂感和随风飘动的感觉）

# 早期
1. C#窗体，特别印象深刻的是里式替换原则和地址动态联动，每次写这个功能都能想起来
2. SQL
3. uml rational rose（当时总感觉这个软件的界面风格是上个世纪的）
	
